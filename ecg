#!/usr/bin/env python3 -B
import numpy.random as r
from numpy import savetxt
from sys import argv

try:
    SEED = int(argv[1])			            # initial seed value
    F1_PROB = float(argv[2])                # probability that first floor will be called
    DT_MAX = int(argv[3])                   # maximum number of seconds between successive calls
    NUM_CALLS = int(argv[4])	            # number of elevator calls to generate
    OUT_FILE = argv[5]			            # the path to which the time series will be written (in plain text)
except:
    exit('usage: ecg [SEED] [F1_PROB] [DT_MAX] [NUM_CALLS] [OUT_FILE]')

MSG_TEMP = "[SEED: {}; NUM_CALLS: {}] => {}"
HEADER_TEMP = 'SEED = {}\nF1_PROB = {}\nDT_MAX = {}\nNUM_CALLS = {}\ntime\tpos\tdest'

offset = 0 					            # seed offset, increment by one every time number is generated
current_time = 0
calls = []

def reseed():
    global offset
    r.seed(SEED + offset)
    offset += 1

def gen_npass():
    reseed()
    N = r.lognormal()		            # default values work: mean=0, standard_deviation=1
    if 0 < N <= 5:			            # will never be less than 0, can be greater than 5
        N = round(N)
    else:
        N = 5
    return N

def gen_floor():			            # generate random floor in range [1, 100]
    reseed()
    a = [floor for floor in range(1, 101)]
    prob = (1 - F1_PROB) / 99           # uniform probability distribution for floors besides first floor
    p = [F1_PROB] + [prob for floor in range(1, 100)]
    return r.choice(a, p=p)

def gen_time():
    global current_time
    reseed()
    time_delta = r.randint(0, DT_MAX)   # next call can occur between 0 and DT_MAX seconds after previous call
    current_time += time_delta
    return current_time		            # round to two decimal places

for i in range(NUM_CALLS):
    ###num_passengers = gen_npass()		# this is irrelevant for part A
    pos = gen_floor()
    dest = gen_floor()
    time = gen_time()
    calls.append( (time, pos, dest)	)

# write array of calls to OUT_FILE
print(MSG_TEMP.format(SEED, NUM_CALLS, OUT_FILE))
header = HEADER_TEMP.format(SEED, F1_PROB, DT_MAX, NUM_CALLS)
fmt = ('%i', '%i', '%i')
savetxt(OUT_FILE, calls, fmt=fmt, header=header, delimiter='\t')